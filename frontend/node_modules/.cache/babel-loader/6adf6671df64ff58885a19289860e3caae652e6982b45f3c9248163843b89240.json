{"ast":null,"code":"import{useState,useEffect,useCallback,useRef}from'react';import{useContext}from'react';import{AuthContext}from'../context/AuthContext';// Simple cache implementation\nconst cache=new Map();export const useFetch=function(url){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const{getAuthAxios}=useContext(AuthContext);const[data,setData]=useState(null);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);const[shouldRefetch,setShouldRefetch]=useState(0);// Store the latest options in a ref to avoid unnecessary re-fetches\nconst optionsRef=useRef(options);optionsRef.current=options;// Cache key generation\nconst getCacheKey=useCallback(()=>{const{skipCache,cacheKey}=optionsRef.current;if(skipCache)return null;return cacheKey||url;},[url]);// Fetch function\nconst fetchData=useCallback(async()=>{const cacheKey=getCacheKey();// Check cache first\nif(cacheKey&&cache.has(cacheKey)&&!optionsRef.current.forceRefresh){const cachedData=cache.get(cacheKey);setData(cachedData);setLoading(false);return;}try{setLoading(true);const axios=getAuthAxios();const response=await axios(url,{...optionsRef.current.axiosOptions});const responseData=response.data;setData(responseData);// Cache the response if caching is enabled\nif(cacheKey&&!optionsRef.current.skipCache){cache.set(cacheKey,responseData);// Set cache expiry if specified\nif(optionsRef.current.cacheExpiry){setTimeout(()=>{cache.delete(cacheKey);},optionsRef.current.cacheExpiry);}}setError(null);}catch(err){setError(err);console.error('Fetch error:',err);}finally{setLoading(false);}},[url,getCacheKey,getAuthAxios]);// Refetch data function\nconst refetch=useCallback(()=>{setShouldRefetch(prev=>prev+1);},[]);// Clear cache function\nconst clearCache=useCallback(()=>{const cacheKey=getCacheKey();if(cacheKey){cache.delete(cacheKey);}},[getCacheKey]);useEffect(()=>{fetchData();},[fetchData,shouldRefetch]);return{data,loading,error,refetch,clearCache};};","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","useContext","AuthContext","cache","Map","useFetch","url","options","arguments","length","undefined","getAuthAxios","data","setData","loading","setLoading","error","setError","shouldRefetch","setShouldRefetch","optionsRef","current","getCacheKey","skipCache","cacheKey","fetchData","has","forceRefresh","cachedData","get","axios","response","axiosOptions","responseData","set","cacheExpiry","setTimeout","delete","err","console","refetch","prev","clearCache"],"sources":["C:/Users/trand/OneDrive/Documents/GitHub/SchoolMedicalManagement/frontend/src/hooks/useFetch.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { useContext } from 'react';\r\nimport { AuthContext } from '../context/AuthContext';\r\n\r\n// Simple cache implementation\r\nconst cache = new Map();\r\n\r\nexport const useFetch = (url, options = {}) => {\r\n  const { getAuthAxios } = useContext(AuthContext);\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const [shouldRefetch, setShouldRefetch] = useState(0);\r\n  \r\n  // Store the latest options in a ref to avoid unnecessary re-fetches\r\n  const optionsRef = useRef(options);\r\n  optionsRef.current = options;\r\n  \r\n  // Cache key generation\r\n  const getCacheKey = useCallback(() => {\r\n    const { skipCache, cacheKey } = optionsRef.current;\r\n    if (skipCache) return null;\r\n    return cacheKey || url;\r\n  }, [url]);\r\n  \r\n  // Fetch function\r\n  const fetchData = useCallback(async () => {\r\n    const cacheKey = getCacheKey();\r\n    \r\n    // Check cache first\r\n    if (cacheKey && cache.has(cacheKey) && !optionsRef.current.forceRefresh) {\r\n      const cachedData = cache.get(cacheKey);\r\n      setData(cachedData);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      setLoading(true);\r\n      const axios = getAuthAxios();\r\n      const response = await axios(url, {\r\n        ...optionsRef.current.axiosOptions\r\n      });\r\n      \r\n      const responseData = response.data;\r\n      setData(responseData);\r\n      \r\n      // Cache the response if caching is enabled\r\n      if (cacheKey && !optionsRef.current.skipCache) {\r\n        cache.set(cacheKey, responseData);\r\n        \r\n        // Set cache expiry if specified\r\n        if (optionsRef.current.cacheExpiry) {\r\n          setTimeout(() => {\r\n            cache.delete(cacheKey);\r\n          }, optionsRef.current.cacheExpiry);\r\n        }\r\n      }\r\n      \r\n      setError(null);\r\n    } catch (err) {\r\n      setError(err);\r\n      console.error('Fetch error:', err);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [url, getCacheKey, getAuthAxios]);\r\n  \r\n  // Refetch data function\r\n  const refetch = useCallback(() => {\r\n    setShouldRefetch(prev => prev + 1);\r\n  }, []);\r\n  \r\n  // Clear cache function\r\n  const clearCache = useCallback(() => {\r\n    const cacheKey = getCacheKey();\r\n    if (cacheKey) {\r\n      cache.delete(cacheKey);\r\n    }\r\n  }, [getCacheKey]);\r\n  \r\n  useEffect(() => {\r\n    fetchData();\r\n  }, [fetchData, shouldRefetch]);\r\n  \r\n  return { data, loading, error, refetch, clearCache };\r\n};"],"mappings":"AAAA,OAASA,QAAQ,CAAEC,SAAS,CAAEC,WAAW,CAAEC,MAAM,KAAQ,OAAO,CAChE,OAASC,UAAU,KAAQ,OAAO,CAClC,OAASC,WAAW,KAAQ,wBAAwB,CAEpD;AACA,KAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CAEvB,MAAO,MAAM,CAAAC,QAAQ,CAAG,QAAAA,CAACC,GAAG,CAAmB,IAAjB,CAAAC,OAAO,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CACxC,KAAM,CAAEG,YAAa,CAAC,CAAGV,UAAU,CAACC,WAAW,CAAC,CAChD,KAAM,CAACU,IAAI,CAAEC,OAAO,CAAC,CAAGhB,QAAQ,CAAC,IAAI,CAAC,CACtC,KAAM,CAACiB,OAAO,CAAEC,UAAU,CAAC,CAAGlB,QAAQ,CAAC,IAAI,CAAC,CAC5C,KAAM,CAACmB,KAAK,CAAEC,QAAQ,CAAC,CAAGpB,QAAQ,CAAC,IAAI,CAAC,CACxC,KAAM,CAACqB,aAAa,CAAEC,gBAAgB,CAAC,CAAGtB,QAAQ,CAAC,CAAC,CAAC,CAErD;AACA,KAAM,CAAAuB,UAAU,CAAGpB,MAAM,CAACO,OAAO,CAAC,CAClCa,UAAU,CAACC,OAAO,CAAGd,OAAO,CAE5B;AACA,KAAM,CAAAe,WAAW,CAAGvB,WAAW,CAAC,IAAM,CACpC,KAAM,CAAEwB,SAAS,CAAEC,QAAS,CAAC,CAAGJ,UAAU,CAACC,OAAO,CAClD,GAAIE,SAAS,CAAE,MAAO,KAAI,CAC1B,MAAO,CAAAC,QAAQ,EAAIlB,GAAG,CACxB,CAAC,CAAE,CAACA,GAAG,CAAC,CAAC,CAET;AACA,KAAM,CAAAmB,SAAS,CAAG1B,WAAW,CAAC,SAAY,CACxC,KAAM,CAAAyB,QAAQ,CAAGF,WAAW,CAAC,CAAC,CAE9B;AACA,GAAIE,QAAQ,EAAIrB,KAAK,CAACuB,GAAG,CAACF,QAAQ,CAAC,EAAI,CAACJ,UAAU,CAACC,OAAO,CAACM,YAAY,CAAE,CACvE,KAAM,CAAAC,UAAU,CAAGzB,KAAK,CAAC0B,GAAG,CAACL,QAAQ,CAAC,CACtCX,OAAO,CAACe,UAAU,CAAC,CACnBb,UAAU,CAAC,KAAK,CAAC,CACjB,OACF,CAEA,GAAI,CACFA,UAAU,CAAC,IAAI,CAAC,CAChB,KAAM,CAAAe,KAAK,CAAGnB,YAAY,CAAC,CAAC,CAC5B,KAAM,CAAAoB,QAAQ,CAAG,KAAM,CAAAD,KAAK,CAACxB,GAAG,CAAE,CAChC,GAAGc,UAAU,CAACC,OAAO,CAACW,YACxB,CAAC,CAAC,CAEF,KAAM,CAAAC,YAAY,CAAGF,QAAQ,CAACnB,IAAI,CAClCC,OAAO,CAACoB,YAAY,CAAC,CAErB;AACA,GAAIT,QAAQ,EAAI,CAACJ,UAAU,CAACC,OAAO,CAACE,SAAS,CAAE,CAC7CpB,KAAK,CAAC+B,GAAG,CAACV,QAAQ,CAAES,YAAY,CAAC,CAEjC;AACA,GAAIb,UAAU,CAACC,OAAO,CAACc,WAAW,CAAE,CAClCC,UAAU,CAAC,IAAM,CACfjC,KAAK,CAACkC,MAAM,CAACb,QAAQ,CAAC,CACxB,CAAC,CAAEJ,UAAU,CAACC,OAAO,CAACc,WAAW,CAAC,CACpC,CACF,CAEAlB,QAAQ,CAAC,IAAI,CAAC,CAChB,CAAE,MAAOqB,GAAG,CAAE,CACZrB,QAAQ,CAACqB,GAAG,CAAC,CACbC,OAAO,CAACvB,KAAK,CAAC,cAAc,CAAEsB,GAAG,CAAC,CACpC,CAAC,OAAS,CACRvB,UAAU,CAAC,KAAK,CAAC,CACnB,CACF,CAAC,CAAE,CAACT,GAAG,CAAEgB,WAAW,CAAEX,YAAY,CAAC,CAAC,CAEpC;AACA,KAAM,CAAA6B,OAAO,CAAGzC,WAAW,CAAC,IAAM,CAChCoB,gBAAgB,CAACsB,IAAI,EAAIA,IAAI,CAAG,CAAC,CAAC,CACpC,CAAC,CAAE,EAAE,CAAC,CAEN;AACA,KAAM,CAAAC,UAAU,CAAG3C,WAAW,CAAC,IAAM,CACnC,KAAM,CAAAyB,QAAQ,CAAGF,WAAW,CAAC,CAAC,CAC9B,GAAIE,QAAQ,CAAE,CACZrB,KAAK,CAACkC,MAAM,CAACb,QAAQ,CAAC,CACxB,CACF,CAAC,CAAE,CAACF,WAAW,CAAC,CAAC,CAEjBxB,SAAS,CAAC,IAAM,CACd2B,SAAS,CAAC,CAAC,CACb,CAAC,CAAE,CAACA,SAAS,CAAEP,aAAa,CAAC,CAAC,CAE9B,MAAO,CAAEN,IAAI,CAAEE,OAAO,CAAEE,KAAK,CAAEwB,OAAO,CAAEE,UAAW,CAAC,CACtD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}